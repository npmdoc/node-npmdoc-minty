<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://www.mintyjs.com">minty (v0.5.10)</a>
</h1>
<h4>Node process visualization</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.minty">module minty</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minty.file">
            function <span class="apidocSignatureSpan">minty.</span>file
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minty.wrap">
            function <span class="apidocSignatureSpan">minty.</span>wrap
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minty.</span>createLineRules</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minty.</span>parser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minty.</span>run</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minty.</span>tools</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minty.</span>viz</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.minty.createLineRules">module minty.createLineRules</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minty.createLineRules.addLines">
            function <span class="apidocSignatureSpan">minty.createLineRules.</span>addLines
            <span class="apidocSignatureSpan">(type, rule, cluster, lineActivity)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minty.createLineRules.addScopeName">
            function <span class="apidocSignatureSpan">minty.createLineRules.</span>addScopeName
            <span class="apidocSignatureSpan">(cluster, lineActivity)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minty.createLineRules.addVariables">
            function <span class="apidocSignatureSpan">minty.createLineRules.</span>addVariables
            <span class="apidocSignatureSpan">(cluster, lineActivity)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minty.createLineRules.ruler">
            function <span class="apidocSignatureSpan">minty.createLineRules.</span>ruler
            <span class="apidocSignatureSpan">(parsed)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.minty.parser">module minty.parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minty.parser.parser">
            function <span class="apidocSignatureSpan">minty.</span>parser
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minty.parser.</span>parseutils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">minty.parser.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.minty.run">module minty.run</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minty.run.runFile">
            function <span class="apidocSignatureSpan">minty.run.</span>runFile
            <span class="apidocSignatureSpan">(fileText, absPath, originalText)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minty.run.wrap">
            function <span class="apidocSignatureSpan">minty.run.</span>wrap
            <span class="apidocSignatureSpan">(wrapText, originalText)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.minty.tools">module minty.tools</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minty.tools.anonFuncCheck">
            function <span class="apidocSignatureSpan">minty.tools.</span>anonFuncCheck
            <span class="apidocSignatureSpan">(jsText)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minty.tools.flattenDeep">
            function <span class="apidocSignatureSpan">minty.tools.</span>flattenDeep
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.minty.viz">module minty.viz</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.minty.viz.Viz">
            function <span class="apidocSignatureSpan">minty.viz.</span>Viz
            <span class="apidocSignatureSpan">(Ig, Fw)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.minty" id="apidoc.module.minty">module minty</a></h1>


    <h2>
        <a href="#apidoc.element.minty.file" id="apidoc.element.minty.file">
        function <span class="apidocSignatureSpan">minty.</span>file
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function file(path) {
  const JSTEXT = fs.readFileSync(path).toString();
  const parsed = parser(JSTEXT);
  const rules = ruler(parsed);
  const injected = inject(rules, JSTEXT);
  run.runFile(injected, path, JSTEXT);
  return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Requires Node.js 4.0 or greater.

## How-To

1. `npm install -g minty` or `npm install --save-dev minty` (don't use minty in production!)
1. `const minty = require ('minty');` in the file you'd like to analyze
1. You can execute an entire file by typing `minty.<span class="apidocCodeKeywordSpan">file</span>(//path to file)`. Note, the file
 path must be absolute, e.g. `minty.file(path.join(__dirname, ../lib/test.js))`
1. You can also 'mintify' a function by typing `var newFunc = minty.wrap(initialFunc)`, and then execute it by calling
 `newFunc()`
1. Run your code as usual (e.g. `node minty.js`) to generate the minty output. A new minty folder will appear in your root directory
1. Open the minty.html file in your browser in either the 'file' or 'function' folder (depending on whether
you executed a file, function, or both). Note: data is stored in the mintyVis.js
1. Click forward and back to step through your variables' state as your app executes!

## Gotchas
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minty.wrap" id="apidoc.element.minty.wrap">
        function <span class="apidocSignatureSpan">minty.</span>wrap
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrap(func) {
  const JSTEXT = func.toString();
  const namedJsFunc = anonFunc(JSTEXT);
  const parsed = parser(namedJsFunc);
  const rules = ruler(parsed);
  const injected = inject(rules, namedJsFunc);
  const mintified = run.wrap(injected, namedJsFunc);
  return function() {
    const args = Array.prototype.slice.call(arguments);
    return mintified.apply(null, args);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Requires Node.js 4.0 or greater.

## How-To

1. `npm install -g minty` or `npm install --save-dev minty` (don't use minty in production!)
1. `const minty = require ('minty');` in the file you'd like to analyze
1. You can execute an entire file by typing `minty.file(//path to file)`. Note, the file path must be absolute, e.g. `minty.file
(path.join(__dirname, ../lib/test.js))`
1. You can also 'mintify' a function by typing `var newFunc = minty.<span class="apidocCodeKeywordSpan">wrap</span>(initialFunc
)`, and then execute it by calling `newFunc()`
1. Run your code as usual (e.g. `node minty.js`) to generate the minty output. A new minty folder will appear in your root directory
1. Open the minty.html file in your browser in either the 'file' or 'function' folder (depending on whether
you executed a file, function, or both). Note: data is stored in the mintyVis.js
1. Click forward and back to step through your variables' state as your app executes!

## Gotchas

* If you globally declare a variable without using let, var, or const, we won't track it.
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.minty.createLineRules" id="apidoc.module.minty.createLineRules">module minty.createLineRules</a></h1>


    <h2>
        <a href="#apidoc.element.minty.createLineRules.addLines" id="apidoc.element.minty.createLineRules.addLines">
        function <span class="apidocSignatureSpan">minty.createLineRules.</span>addLines
        <span class="apidocSignatureSpan">(type, rule, cluster, lineActivity)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addLines(type, rule, cluster, lineActivity) {
  let startLine;
  let endLine;
  cluster.forEach(group =&gt; {
    startLine = group.startLine - 1;
    endLine = group.endLine - 1;
    if (!lineActivity[startLine]) lineActivity[startLine] = {};
    if (!lineActivity[startLine].rulesFound) lineActivity[startLine].rulesFound = [];
    if (rule) {
      lineActivity[startLine].rulesFound.push({ action: 'START', rule, type });
    }
    if (!lineActivity[endLine]) lineActivity[endLine] = {};
    if (!lineActivity[endLine].rulesFound) lineActivity[endLine].rulesFound = [];
    if (rule) {
      lineActivity[endLine].rulesFound.push({ action: 'END', rule, type });
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function ruler(parsed) {
let lineActivity = {};
Object.keys(parsed).forEach(type =&gt; {
  switch (type) {
    case 'BreakStatement':
    case 'ReturnStatement':
    case 'YieldExpression':
      lineRules.<span class="apidocCodeKeywordSpan">addLines</span>(type, 'SWAP', parsed[type], lineActivity);
      break;
    case 'FunctionDeclaration':
    case 'FunctionExpression':
    case 'ArrowFunctionExpression':
    case 'SwitchCase':
      lineRules.addLines(type, 'SCOPE', parsed[type], lineActivity);
      lineRules.addVariables(parsed[type], lineActivity);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minty.createLineRules.addScopeName" id="apidoc.element.minty.createLineRules.addScopeName">
        function <span class="apidocSignatureSpan">minty.createLineRules.</span>addScopeName
        <span class="apidocSignatureSpan">(cluster, lineActivity)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addScopeName(cluster, lineActivity) {

  cluster.forEach(group =&gt; {
    const line = lineActivity[group.startLine - 1];
    if (group.name) {
      line.scope = group.name;
    } else if (group.parameters) {
      if (line.variables.variables) {
        line.scope = line.variables.variables.names.join('');
      } else {
        line.scope = 'anonymous function';
      }
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break;
case 'FunctionDeclaration':
case 'FunctionExpression':
case 'ArrowFunctionExpression':
case 'SwitchCase':
  lineRules.addLines(type, 'SCOPE', parsed[type], lineActivity);
  lineRules.addVariables(parsed[type], lineActivity);
  lineRules.<span class="apidocCodeKeywordSpan">addScopeName</span>(parsed[type], lineActivity);
  break;
case 'VariableDeclaration':
  lineRules.addLines(type, null, parsed[type], lineActivity);
  lineRules.addVariables(parsed[type], lineActivity);
  break;
case 'CallExpression':
case 'SwitchStatement':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minty.createLineRules.addVariables" id="apidoc.element.minty.createLineRules.addVariables">
        function <span class="apidocSignatureSpan">minty.createLineRules.</span>addVariables
        <span class="apidocSignatureSpan">(cluster, lineActivity)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addVariables(cluster, lineActivity) {
  cluster.forEach(group =&gt; {
    const line = lineActivity[group.startLine - 1];
    if (!line.variables) line.variables = {};
    if (group.parameters) {
      line.variables.parameters = group.parameters;
    }
    if (group.variables) {
      line.variables.variables = {
        names: group.variables,
        kind: group.kind,
      };
    }
  });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  lineRules.addLines(type, 'SWAP', parsed[type], lineActivity);
  break;
case 'FunctionDeclaration':
case 'FunctionExpression':
case 'ArrowFunctionExpression':
case 'SwitchCase':
  lineRules.addLines(type, 'SCOPE', parsed[type], lineActivity);
  lineRules.<span class="apidocCodeKeywordSpan">addVariables</span>(parsed[type], lineActivity);
  lineRules.addScopeName(parsed[type], lineActivity);
  break;
case 'VariableDeclaration':
  lineRules.addLines(type, null, parsed[type], lineActivity);
  lineRules.addVariables(parsed[type], lineActivity);
  break;
case 'CallExpression':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minty.createLineRules.ruler" id="apidoc.element.minty.createLineRules.ruler">
        function <span class="apidocSignatureSpan">minty.createLineRules.</span>ruler
        <span class="apidocSignatureSpan">(parsed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ruler(parsed) {
  let lineActivity = {};
  Object.keys(parsed).forEach(type =&gt; {
    switch (type) {
      case 'BreakStatement':
      case 'ReturnStatement':
      case 'YieldExpression':
        lineRules.addLines(type, 'SWAP', parsed[type], lineActivity);
        break;
      case 'FunctionDeclaration':
      case 'FunctionExpression':
      case 'ArrowFunctionExpression':
      case 'SwitchCase':
        lineRules.addLines(type, 'SCOPE', parsed[type], lineActivity);
        lineRules.addVariables(parsed[type], lineActivity);
        lineRules.addScopeName(parsed[type], lineActivity);
        break;
      case 'VariableDeclaration':
        lineRules.addLines(type, null, parsed[type], lineActivity);
        lineRules.addVariables(parsed[type], lineActivity);
        break;
      case 'CallExpression':
      case 'SwitchStatement':
        lineRules.addLines(type, 'VOID', parsed[type], lineActivity);
        break;
      default:
        lineRules.addLines(type, 'SCOPE', parsed[type], lineActivity);
        break;
    }
  });
  return lineActivity;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.minty.parser" id="apidoc.module.minty.parser">module minty.parser</a></h1>


    <h2>
        <a href="#apidoc.element.minty.parser.parser" id="apidoc.element.minty.parser.parser">
        function <span class="apidocSignatureSpan">minty.</span>parser
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parser(text) {
  parseutils.cache = {};

  ast = esprima.parse(text, {
    loc: true,
  });

  parseutils.asyncTasks.forEach(func =&gt; {
    func();
  });
  return parseutils.cache;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.minty.run" id="apidoc.module.minty.run">module minty.run</a></h1>


    <h2>
        <a href="#apidoc.element.minty.run.runFile" id="apidoc.element.minty.run.runFile">
        function <span class="apidocSignatureSpan">minty.run.</span>runFile
        <span class="apidocSignatureSpan">(fileText, absPath, originalText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function runFile(fileText, absPath, originalText) {
  const fileJS = fileText.log.join('\n');
  log = [];
  filename = absPath.slice(absPath.lastIndexOf('/') + 1);
  try {
    _eval(fileJS, filename, {
      mintyLog: mintyLog,
    }, true);
  } catch (err) {
    console.log(`\n\n#################################################################################\nMinty has found an error
! Please check the out put of ${filename} for more details\n#################################################################################\n`);
    errorHandler(err, fileText);
  } finally {
    const output = {
      entry: filename,
      log: log,
    };
    output[filename] = originalText;
    const fileOutput = finalizeOutput(output);
    finalizeRun(fileOutput, 'file');
    console.log(`Minty has finished analyzing ${filename}`);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
**/

function file(path) {
  const JSTEXT = fs.readFileSync(path).toString();
  const parsed = parser(JSTEXT);
  const rules = ruler(parsed);
  const injected = inject(rules, JSTEXT);
  run.<span class="apidocCodeKeywordSpan">runFile</span>(injected, path, JSTEXT);
  return;
}

/**
* turns function to a string, turns function into abstract syntax tree, creates rules to inject monitoring code, and returns function
 that will output HTML file each time it is called
* @param {function}
* @returns {function} each time returned function is executed, an HTML visualization will be created
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minty.run.wrap" id="apidoc.element.minty.run.wrap">
        function <span class="apidocSignatureSpan">minty.run.</span>wrap
        <span class="apidocSignatureSpan">(wrapText, originalText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrap(wrapText, originalText) {
  let returnStatement;
  log = [];
  filename = wrapText.log[1]
    .split(',')[2]
    .replace(/\s+|\]|\'|\"/g, '');
  const wrapJS = wrapText.log.join('\n');
  return function() {
    const args = Array.prototype.slice.call(arguments);
    try {
      const fn = eval(`(${wrapJS})`);
      returnStatement = fn.apply(null, args);
    } catch (err) {
      console.log(`\n\n#################################################################################\nMinty has found an error
! Please check the out put of ${filename} for more details\n#################################################################################\n`);
      errorHandler(err, wrapText);
    } finally {
      const output = {
        entry: filename,
        log: log,
      };
      output[filename] = originalText;
      const wrapOutput = finalizeOutput(output);
      finalizeRun(wrapOutput, 'function');
    }
    return returnStatement;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Requires Node.js 4.0 or greater.

## How-To

1. `npm install -g minty` or `npm install --save-dev minty` (don't use minty in production!)
1. `const minty = require ('minty');` in the file you'd like to analyze
1. You can execute an entire file by typing `minty.file(//path to file)`. Note, the file path must be absolute, e.g. `minty.file
(path.join(__dirname, ../lib/test.js))`
1. You can also 'mintify' a function by typing `var newFunc = minty.<span class="apidocCodeKeywordSpan">wrap</span>(initialFunc
)`, and then execute it by calling `newFunc()`
1. Run your code as usual (e.g. `node minty.js`) to generate the minty output. A new minty folder will appear in your root directory
1. Open the minty.html file in your browser in either the 'file' or 'function' folder (depending on whether
you executed a file, function, or both). Note: data is stored in the mintyVis.js
1. Click forward and back to step through your variables' state as your app executes!

## Gotchas

* If you globally declare a variable without using let, var, or const, we won't track it.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.minty.tools" id="apidoc.module.minty.tools">module minty.tools</a></h1>


    <h2>
        <a href="#apidoc.element.minty.tools.anonFuncCheck" id="apidoc.element.minty.tools.anonFuncCheck">
        function <span class="apidocSignatureSpan">minty.tools.</span>anonFuncCheck
        <span class="apidocSignatureSpan">(jsText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function anonFuncCheck(jsText) {
  if (jsText[9] === '(') {
    const namedAnonFunc = jsText.replace(jsText[8], ' anonymousFunc');
    return namedAnonFunc;
  }
  return jsText;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.minty.tools.flattenDeep" id="apidoc.element.minty.tools.flattenDeep">
        function <span class="apidocSignatureSpan">minty.tools.</span>flattenDeep
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flattenDeep(array) {
  if (array) {
    let flattenArray = [];
    for (let i = 0; i &lt; array.length; i++) {
      const element = array[i];
      if (element.constructor === Array) {
        flattenArray = flattenArray.concat(flattenDeep(element));
      } else {
        flattenArray.push(element);
      }
    }
    return flattenArray;
  }
  return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.minty.viz" id="apidoc.module.minty.viz">module minty.viz</a></h1>


    <h2>
        <a href="#apidoc.element.minty.viz.Viz" id="apidoc.element.minty.viz.Viz">
        function <span class="apidocSignatureSpan">minty.viz.</span>Viz
        <span class="apidocSignatureSpan">(Ig, Fw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Viz = function (Ig, Fw){function Gn(a){eval.call(Mc,a)}function Kg(a){I.print(a+":\n"+Error().stack);Tb("Assertion: "+a)}function ld(a,
b){a||Kg("Assertion failed: "+b)}function Hn(a){try{var b=eval("_"+a)}catch(f){try{b=Gw.Module["_"+a]}catch(e){}}ld(b,"Cannot call
 unknown function "+a+" (perhaps LLVM optimizations or closure removed it?)");return b}function In(a,b,f,e){function n(a,b){if("
string"==b){if(a===Mc||a===ic||0===a){return 0}k||(k=pa.na());var s=pa.ma(a.length+1);Jn(a,s);return s}return"array"==b?(k||(k=pa
.na()),s=pa.ma(a.length),Kn(a,s),s):a}var k=0,j=0,e=e?e.map((function(a){return n(a,f[j++])})):[];a=a.apply(Mc,e);"string"==b?b=
De(a):(ld("array"!=b),b=a);k&amp;&amp;pa.Ha(k);return b}function Lg(s,i,f){f=f||"i8";"*"===f.charAt(f.length-1)&amp;&amp;(f="i32");switch(f){case
"i1":m[s]=i;break;case"i8":m[s]=i;break;case"i16":D[s&gt;&gt;1]=i;break;case"i32":a[s&gt;&gt;2]=i;break;case"i64":Pf=[i&gt;&gt;&gt;0,Math.min(Math.floor
(i/4294967296),4294967295)&gt;&gt;&gt;0];a[s&gt;&gt;2]=Pf[0];a[s+4&gt;&gt;2]=Pf[1];break;case"float":vb[s&gt;&gt;2]=i;break;case"double":g[b&gt;&gt;3]=i;a[s&gt;&gt;2]=
a[b&gt;&gt;2];a[s+4&gt;&gt;2]=a[b+4&gt;&gt;2];break;default:Kg("invalid type for setValue: "+f)}}function Qf(s,i){i=i||"i8";"*"===i.charAt(i.length
-1)&amp;&amp;(i="i32");switch(i){case"i1":return m[s];case"i8":return m[s];case"i16":return D[s&gt;&gt;1];case"i32":return a[s&gt;&gt;2];case"i64":return
 a[s&gt;&gt;2];case"float":return vb[s&gt;&gt;2];case"double":return a[b&gt;&gt;2]=a[s&gt;&gt;2],a[b+4&gt;&gt;2]=a[s+4&gt;&gt;2],g[b&gt;&gt;3];default:Kg("invalid type for
 setValue: "+i)}return Mc}function c(a,b,f,e){var n,k;"number"===typeof a?(n=vc,k=a):(n=Xd,k=a.length);var j="string"===typeof b
?b:Mc,f=f==d?e:[Hb,pa.ma,pa.oa][f===ic?Ee:f](Math.max(k,j?1:b.length));if(n){return ef(f,0,k),f}if("i8"===j){return E.set(new Uint8Array
(a),f),f}for(n=0;n&lt;k;){var G=a[n];"function"===typeof G&amp;&amp;(G=pa.md(G));e=j||b[n];0===e?n++:("i64"==e&amp;&amp;(e="i32"),Lg(f+n,G,e),n+=pa
.ea(e))}return f}function De(a,b){for(var f=new pa.U,e="undefined"==typeof b,n="",k=0,j;;){j=E[a+k|0];if(e&amp;&amp;0==j){break}n+=f.Da(
j);k+=1;if(!e&amp;&amp;k==b){break}}return n}function $h(a){for(;0&lt;a.length;){var b=a.shift(),f=b.ca;"number"===typeof f?b.W===ic?pa.t("
v",f):pa.t("vi",f,[b.W]):f(b.W===ic?Mc:b.W)}}function ee(a,b,f){a=(new pa.U).jb(a);f&amp;&amp;(a.length=f);b||a.push(0);return a}function
 Jn(a,b,f){a=ee(a,f);for(f=0;f&lt;a.length;){m[b+f|0]=a[f],f+=1}}function Kn(a,b){for(var f=0;f&lt;a.length;f++){m[b+f|0]=a[f]}}function
 Ln(a,b){return 0&lt;=a?a:32&gt;=b?2*Math.abs(1&lt;&lt;b-1)+a:Math.pow(2,b)+a}function Mn(a,b){if(0&gt;=a){return a}var f=32&gt;=b?Math.abs(1&lt;&lt;b-1
):Math.pow(2,b-1);if(a&gt;=f&amp;&amp;(32&gt;=b||a&gt;f)){a=-2*f+a}return a}function Aj(a){rf++;I.monitorRunDependencies&amp;&amp;I.monitorRunDependencies
(rf);a?(ld(!Mg[a]),Mg[a]=1,Ng===Mc&amp;&amp;"undefined"!==typeof setInterval&amp;&amp;(Ng=setInterval((function(){var a=Xd,b;for(b in Mg){a||(a=
vc,I.o("still waiting on run dependencies:")),I.o("dependency: "+b)}a&amp;&amp;I.o("(end of list)")}),6e3))):I.o("warning: run dependency
 added without ID")}function ai(a){rf--;I.monitorRunDependencies&amp;&amp;I.monitorRunDependencies(rf);a?(ld(Mg[a]),delete Mg[a]):I.o("warning
: run dependency removed without ID");0==rf&amp;&amp;(Ng!==Mc&amp;&amp;(clearInterval(Ng),Ng=Mc),!Nn&amp;&amp;Bj&amp;&amp;Cj())}function md(a,b,f){for(var e=0;e
&lt;f;){var n=E[a+e|0],k=E[b+e|0];if(n==k&amp;&amp;0==n){break}if(0==n){return-1}if(0==k){return 1}if(n==k){e++}else{return n&gt;k?1:-1}}return
 0}function ea(a,b){return md(a,b,Og)}function ie(a,b,f){for(var a=a|0,b=b|0,f=f|0,e=0,n=0,k=0;(e|0)&lt;(f|0);){n=E[a+e|0];k=E[b+e|
0];if((n|0)!=(k|0)){return((n|0)&gt;(k|0)?1:-1)|0}e=e+1|0}return 0}function Fc(b,i,f){b|=0;i|=0;f|=0;if((b&amp;3)==(i&amp;3)){for(;b&amp;3;){if
(0==(f|0)){return}m[b]=m[i];b=b+1|0;i=i+1|0;f=f-1|0}for(;4&lt;=(f|0);){a[b&gt;&gt;2]=a[i&gt;&gt;2],b=b+4|0,i=i+4|0,f=f-4|0}}for(;0&lt;(f|0);){m[b]=
m[i],b=b+1|0,i=i+1|0,f=f-1|0}}function Wa(a){for(var a=a|0,b=0,b=a;m[b]|0;){b=b+1|0}return b-a|0}function fb(b){fb.d||(fb.d=c([0
],"i32",Ee));return a[fb.d&gt;&gt;2]=b}function Hw(a,b,f){var e=Q.b[a];if(e){if(e.q){if(0&gt;f){return fb(Cb.i),-1}if(e.object.e){if(e.object
.m){for(var n=0;n&lt;f;n++){try{e.object.m(m[b+n|0])}catch(k){return fb(Cb.r),-1}}e.object.timestamp=Date.now();return n}fb(Cb.ra);
return-1}n=e.position;a=Q.b[a];if(!a||a.object.e){fb(Cb.l) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>